#include <Rinternals.h>
#include <R_ext/Rdynload.h>
#include "helper.h"

SEXP is_hashed(SEXP env){
  return ScalarLogical((HASHTAB(env)!=R_NilValue)? TRUE: FALSE);
}

SEXP hash_table(SEXP env){
  SEXP ret, ans = R_NilValue, frame;
  SEXP ht = HASHTAB(env);
  int n, i, j;

  if (ht==R_NilValue) return ans;

  n = length(ht);

  PROTECT(ret = allocList(n));
  ans = ret;

  for (i = 0; i < n; i++){
    printf("i: %i \n",i); /* where are we? */
    frame = VECTOR_ELT(ht,i);
    j = 0;
    /* Count number of elements */
    while (frame != R_NilValue) {
      printf("i: %i, j: %i \n",i,j); /* where are we? */
      j++;
      frame = CDR(frame);
    }
    if (j == 0){
      printf("j == 0 \n");
      SETCAR(ans,R_NilValue);
    } else {
      printf("j != 0 \n");
      SETCAR(ans,allocVector(STRSXP,j));
      frame = VECTOR_ELT(ht,i);
      j = 0;
      while (frame != R_NilValue) {
        printf("i: %i, j: %i \n",i,j); /* where are we? */
        SET_STRING_ELT(CAR(ans),j,PRINTNAME(TAG(frame)));
        j++;
        frame = CDR(frame);
      }
    }
    ans = CDR(ans);
  }

  UNPROTECT(1);
  return ret;
};


/* ################################################################################
 * Working version without ... additional arguments
################################################################################ */

SEXP eapply2(SEXP env, SEXP fn, SEXP rho){
  if(!isEnvironment(env)) error("'env' should be an environment");

    int n = HashTableSize(HASHTAB(env), 0);
    SEXP R_fcall;

    /* elements of hash table to map f(...) over */
    SEXP tmp;
    PROTECT(tmp = allocVector(VECSXP, n));
    int k2 = 0;
    HashTableValues(HASHTAB(env), 0, tmp, &k2);

    if(!isFunction(fn)) error("'fn' must be a function");
    if(!isEnvironment(rho)) error("'rho' should be an environment");

    R_fcall = PROTECT(lang2(fn, R_NilValue));
    for(int i = 0; i < n; i++) {
      SETCADR(R_fcall, VECTOR_ELT(tmp, i));
      eval(R_fcall, rho);
    }
    UNPROTECT(2);
    return R_NilValue;
}

/*
 * call: a language object generated by match.call(expand.dots = FALSE)
*/
SEXP eapply3(SEXP call, SEXP rho){

  /* advance to 2nd element (CAR) of call pairlist; 1st element is just the eapply3 function */
  SEXP args = CDR(call);

  /* get environment (2nd element) and advance to 3rd element */
  SEXP envSymbol = install("X");
  args = CDR(args);

  /* get function (3rd element) and advance to 4th element */
  SEXP funSymbol = install("FUN");
  args = CDR(args);

  /* env is the hash table */
  SEXP env = PROTECT(eval(envSymbol,rho));
  int n = HashTableSize(HASHTAB(env), 0);
  printf("n: %i\n",n);

  /* get the values out of the hash table as vector/list: vals */
  SEXP vals;
  PROTECT(vals = allocVector(VECSXP,n));
  int ix = 0;
  HashTableValues(HASHTAB(env), 0, vals, &ix);

  /* make the bit of the function call that indexes over the values in the hash table */
  SEXP tmp;
  PROTECT(tmp = LCONS(R_Bracket2Symbol, LCONS(envSymbol, R_NilValue)));

  /* make the f(X[[i]],...) bit of the function call (tmp is the indexing) */
  SEXP R_fcall;
  PROTECT(R_fcall = LCONS(funSymbol, LCONS(tmp , LCONS(R_DotsSymbol,R_NilValue))));

  /* map the function(...) over the hash table */
  printf("loop over values in hash table\n");
  for(int j=0; j<n; j++){
    printf("j: %i\n",j);
    SETCADR(R_fcall, VECTOR_ELT(vals, j));
    R_forceAndCall(R_fcall, 1, rho);
  };

  UNPROTECT(4);
  return R_NilValue;
}

/* ################################################################################
 * Example to call nested functions with ... being passed down
################################################################################ */

SEXP call_function(SEXP call, SEXP rho){

  /* advance to 2nd element (CAR) of call pairlist; 1st element is just the call_function function */
  SEXP args = CDR(call);

  /* get function (2rd element) and advance to 3th element */
  SEXP funSymbol = install("FUN");
  args = CDR(args);

  /* make the function call */
  SEXP R_fcall;
  PROTECT(R_fcall = LCONS(funSymbol, LCONS(R_DotsSymbol,R_NilValue)));

  /* call the function */
  R_forceAndCall(R_fcall, 1, rho);

  UNPROTECT(1);
  return R_NilValue;
}


/* Lifted from R sources in src/main/envir.c*/
static int hash_function(const char *s)
{
  char *p;
  unsigned h = 0, g;
  for (p = (char *) s; *p; p++) {
    h = (h << 4) + (*p);
    if ((g = h & 0xf0000000) != 0) {
      h = h ^ (g >> 24);
      h = h ^ g;
    }
  }
  return h;
}

SEXP hash_value(SEXP str){
  return ScalarInteger(hash_function(CHAR(STRING_ELT(str,0))));
}

static R_CallMethodDef callMethods[]  = {
  {"C_is_hashed", (DL_FUNC)&is_hashed, 1},
  {"C_hash_table", (DL_FUNC)&hash_table, 1},
  {"C_hash_value", (DL_FUNC)&hash_value, 1},
  {"C_eapply2", (DL_FUNC)&eapply2, 3},
  {"C_eapply3", (DL_FUNC)&eapply3, 2},
 {"C_call_function", (DL_FUNC)&call_function, 2},
  {NULL, NULL, 0}
};

void R_init_envestigate(DllInfo *info){
  R_registerRoutines(info, NULL, callMethods, NULL, NULL);
}
